#ifndef _Cin_H
#define _Cin_H
#include<typeinfo>
#include<iostream>
#include<vector>
#include<limits>
#include<iomanip>
#include"Myex.h"
//#define Isfloat i>0&&static_cast<int>(a[i-1])>=48&&static_cast<int>(a[i-1])<=57&&a[i]=='.'&&i<a.length()-1&&(static_cast<int>(a[i+1])>=48&&static_cast<int>(a[i+1])<=57||a[i+1]=='e')
int _find(const std::string &a,char e){
    int count(0);
    for(int i=0;i<a.length();++i){
        if(a[i]==e){
            count++;
        }
    }
    return count;
}
//Последнюю цифру в строке увеличиваем на 1
std::string& increasestr(std::string &a){
    a[a.length()-1]=static_cast<char>(static_cast<int>(a[a.length()-1])+1);
    return a; 
}
//Последнюю цифру в строке уменьшаем на 1
std::string& decreasestr(std::string &a){
    a[a.length()-1]=static_cast<char>(static_cast<int>(a[a.length()-1])-1);
    return a; 
}
//из строки в число (целочисленное) с проверкой на диапазон
template<typename T>
T getnumber(T min,T max){        

    std::string tmp,a,max_max(std::to_string(std::numeric_limits<T>::max()));bool b(0),minus(0);T count(0);
    
    if(min>max)return 0;

    do{

        try{

            getline(std::cin,a);

            if(a.length()!=0){

                b=1;
                minus=0;
                tmp="";

                //Удаляем ведущие нули в начале 
                if(a.length()==1&&a[0]=='0'){}
                else {
                    while(a[0]=='0'){
                        a.erase(0,1);
                    }
                }
                std::cout<<a<<'\n';
                //проверка на число
                for(int i=0;i<a.length();++i){

                    if(static_cast<int>(a[i])>=48&&static_cast<int>(a[i])<=57){
                        tmp+=a[i];
                    }      
                    //если есть минус
                    else if(i==0&&static_cast<int>(a[i])==45){
                        minus=1;
                        b=1;
                    }
                    else {
                        b=0;
                        throw Myexcept("Not right symbol\n");
                    }
                }
                //удаляем минус если отр число
                if(minus){
                    a.erase(0,1);
                    //так как макс отр число больше по модулю на 1 увеливаем последнюю цифру на 1
                    max_max=increasestr(max_max);
                }
                //проверка на границы
                if(b&&a.length()!=0){
                    //сравнение строк как чисел. если хоть одно число меньше выходим из цикла 
                    if(a.length()==max_max.length()){

                        for(int i=0;i<max_max.length();++i){
                            if(a[i]<max_max[i]){
                                break;
                            }
                            else if(a[i]>max_max[i]){
                                b=0;
                                if(minus)throw Myexcept("too  small number\n");
                                else throw Myexcept("too big number\n");
                            }
                        }//если длина больше максимальной для типа

                    }else if(a.length()>max_max.length()){
                        b=0;
                        if(minus)throw Myexcept("too  small number\n");
                        else throw Myexcept("too big number\n");
                    }

                }
                //минус отдельно обрабатывается
                //если число максимально минимальное
                if(tmp==max_max&&minus){
                    count=(stoll(max_max)*-1);
                    b=1;
                    //if(count<min){b=0;throw Myexcept("too small number\n");}
                    //if(count>max){b=0;throw Myexcept("too big number\n");}
                }
                else if(b&&a.length()!=0){
                    if(minus){
                        count=(-stoll(tmp));
                        //std::cout<<count<<' '<<min<<'\n';
                        //if(count<min){b=0;throw Myexcept("too small number\n");}
                        //if(count>max){b=0;throw Myexcept("too big number\n");}
                    }
                    else if(b&& a.length()!=0){
                        count=(stoll(tmp));
                    }
                }
            }else {
                b=0;
                throw Myexcept("you have not entered anything\n");
            }
            //если только минус
            if(b&&minus&&a.length()==0){
                b=0;
                throw Myexcept("Not right Symbol\n");
            }
            if(count<min){
                b=0;
                throw Myexcept("too small number\n");
            }
            if(count>max){
                b=0;
                throw Myexcept("too big number\n");
            }
        }
        catch(const std::exception &ex){
            std::cout<<ex.what()<<"Try again\n";
        }
    }while(!b);
    return count;    
}
//проверка на double с експоненциальной записью
double getdouble(double min,double max){       

    std::string tmp,a,check;
    bool b(0),minus(0),f(0);
    double count(0);
    int lentoexp(0);

    if(min>max)return 0;

    do{    
        try{
            b=1;
            tmp="";
            a="";
            minus=0;
            //f Для проверки с плавающей точкой
            f=0;
            
            getline(std::cin,a);
            //проверка на 0 отдельно
            if(a.length()!=0){
                /*if(a.length()==1&&a[0]=='0'||(a.length()==3&&a[0]=='0'&&a[1]=='.'&&a[2]=='0')){
                    count=(stod(a));
                    if(count<min){b=0;throw Myexcept("too small number\n");}
                    if(count>max){b=0;throw Myexcept("too big number\n");}
                    b=1;
                    //гарантируем что 0 обработается раз 
                    break;
                }*/
                //удаляем все 0 до точки,если точка то не включая перед ней
                while(a[0]=='0'&&a[1]!='.'&&a.length()>1){
                    a.erase(0,1);
                }
                if(a[0]=='-'){
                    minus=1;
                    a.erase(0,1);
                }
                //проверка на число с плавающей точкой 
                for(int i=0;i<a.length()&&b;++i){
                    if(static_cast<int>(a[i])>=48&&static_cast<int>(a[i])<=57){
                        tmp+=a[i];
                    }
                    //если пред цифра и сейчас точка и след цифра
                    else if(i>0&&static_cast<int>(a[i-1])>=48&&static_cast<int>(a[i-1])<=57&&a[i]=='.'&&i<a.length()-1&&(static_cast<int>(a[i+1])>=48&&static_cast<int>(a[i+1])<=57||a[i+1]=='e')){
                        tmp+='.';
                        //со след если цифры
                        if(_find(a,'e')<=1){
                            for(int j=i+1;j<a.length();++j){
                                if(static_cast<int>(a[j])>=48&&static_cast<int>(a[j])<=57){
                                    tmp+=a[j];
                                    //если точка это ласт символ
                                    if(a.length()==j+1){
                                        f=1;
                                    }//проверка на е
                                }else if(a[j]=='e'){
                                    tmp+=a[j];           
                                }else if((a[j-1]=='e'&&j+1<a.length()-1)&&(a[j]=='-'||a[j]=='+')){
                                    tmp+=a[j];
                                }else{
                                    throw Myexcept("Not right symbol\n");
                                }
                            }
                        }else {
                            throw Myexcept("Not right symbol\n");       
                        }
                    }else {
                        throw Myexcept("Not right symbol\n");
                    }
                    if(f){
                        break;
                    }
                }
                if(b){
                    if(a.length()>15){
                        if(minus)throw Myexcept("too small or long number\n");
                        throw Myexcept("too big or long number\n");
                    }
                    //если только минусы
                    if(minus&&a.length()==0){
                        throw Myexcept("Not right Symbol\n");
                    }
                    //если есть ешка
                    if(_find(a,'e')==1){
                        //проверка е на степень string для этого
                        //получим количество цифр до точки чтобы подправить макс степень e
                        check="";
                        lentoexp=a.substr(0,a.find('.')).length();
                        for(int i=0;i<a.length();++i){
                            if(a[i]=='e')for(int j=i+1;j<a.length();++j)check+=a[j];
                        }
                        //-1 чтобы макс степень была на 1 меньше чем возможная
                        if(stoll(check)>(308-lentoexp-1)){
                            throw Myexcept("too big number\n");
                        }else if(stoll(check)<(-308-lentoexp+1)||(minus&&abs(stoll(check))<(308-lentoexp-1))){
                            throw Myexcept("too small number\n");
                        }
                    }
                }
                if(b){
                    // из строки в число если с минусом
                    if(minus){
                        count=(-stod(tmp));
                        //std::cout<<"count "<<count<<" "<<min<<'\n';
                        //if(count<min){throw Myexcept("too small number\n");}
                        //if(count>max){throw Myexcept("too big number\n");}
                    }// без минуса
                    else{
                        count=stod(tmp);
                        //if(count<min){throw Myexcept("too small number\n");}
                        //if(count>max){throw Myexcept("too big number\n");}
                    }
                }
            }else{
                throw Myexcept("you have not entered anything\n"); 
            }
            if(count<min){throw Myexcept("too small number\n");}
            if(count>max){throw Myexcept("too big number\n");}
        }
        catch(const std::exception& ex){
            std::cout<<ex.what()<<'\n'<<"Try Again\n";
            b=0;
        }
    }while(!b);
    return count;    
}

template<class T>
class _Cin{
private:
    std::vector<T> m_data;
public:
    _Cin(int c=1){ 
        if(typeid(m_data)==typeid(std::vector<int>)||typeid(m_data)==typeid(std::vector<short>)||typeid(m_data)==typeid(std::vector<long long int>)){
            do{
                m_data.push_back(getnumber(std::numeric_limits<T>::lowest(),std::numeric_limits<T>::max()));
            }while(m_data.size()<c);
        }else if(typeid(m_data)==typeid(std::vector<double>)){
            do{
                //lowest так как мин возвращает полож число минимальное 
                m_data.push_back(getdouble(std::numeric_limits<T>::lowest(),std::numeric_limits<T>::max()));
            }while(m_data.size()<c);
        }else{
            std::cout<<"this type is not supported\n";
        }
    }  
    _Cin(T min,T max,int c=1){
        if(typeid(m_data)==typeid(std::vector<int>)){
            min<std::numeric_limits<T>::min()?min=std::numeric_limits<T>::min():min=min;
            max>std::numeric_limits<T>::max()?max=std::numeric_limits<T>::max():max=max; 
            do{
                m_data.push_back(getnumber(min,max));
            }while(m_data.size()<c);
        }else if(typeid(m_data)==typeid(std::vector<double>)){
            do{
                m_data.push_back(getdouble(min,max));
            }while(m_data.size()<c);
        }else{
            std::cout<<"this type is not supported\n";
        }
    }
    void print(){
        for(auto &v:m_data)std::cout<<v<<' ';
    }
    std::vector<T>& getvec(){
        return m_data; 
    }
    T getvalue(){
        return m_data[0];
    }
    operator std::vector<T>&(){return m_data;}
    operator T(){return m_data[0];}
};
#endif
