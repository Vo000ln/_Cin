#ifndef _Cin_H
#define _Cin_H
#include<typeinfo>
#include<iostream>
#include<vector>
#include<cassert>
#include<limits>
#include<limits.h>
#include<float.h>
#ifndef Isfloat 
#define Isfloat i>0&&static_cast<int>(a[i-1])>=48&&static_cast<int>(a[i-1])<=57&&a[i]=='.'&&i<a.length()-1&&static_cast<int>(a[i+1])>=48&&static_cast<int>(a[i+1])<=57
#endif
//Последнюю цифру в строке увеличиваем на 1
std::string& increasestr(std::string &a){
    a[a.length()-1]=static_cast<char>(static_cast<int>(a[a.length()-1])+1);
    return a; 
}
//Последнюю цифру в строке уменьшаем на 1
std::string& decreasestr(std::string &a){
    a[a.length()-1]=static_cast<char>(static_cast<int>(a[a.length()-1])-1);
    return a; 
}
//из строки в число (целочисленное) с проверкой на диапазон
template<typename T>
T getnumber(T min,T max){        
    std::string tmp,a,max_max(std::to_string(std::numeric_limits<decltype(min)>::max()));bool b(0),minus(0);T count(0);
    do{
        try{
            getline(std::cin,a);
            if(a.length()!=0){
                b=1;
                minus=0;
                tmp="";
                //Удаляем ведущие нули в начале 
                if(a.length()==1&&a[0]=='0'){}
                else {
                    while(a[0]=='0'){
                        a.erase(0,1);
                    }
                }
                //проверка на число
                for(int i=0;i<a.length();++i){
                    if(static_cast<int>(a[i])>=48&&static_cast<int>(a[i])<=57){
                        tmp+=a[i];
                    }    
                    else if(i==0&&static_cast<int>(a[i])==45){
                        minus=1;b=1;
                    }
                    else {
                        b=0;
                        throw "Not right symbol\n";
                    }
                }
                //удаляем минус если отр число
                if(minus){
                    a.erase(0,1);
                    max_max=increasestr(max_max);
                }
                //проверка на границы
                if(b&&a.length()!=0){
                    if(a.length()==max_max.length()){
                        for(int i=0;i<max_max.length();++i){
                            if(a[i]<max_max[i]){
                                break;
                            }
                            else if(a[i]>max_max[i]){
                                b=0;
                                if(minus)throw "too  small number\n";
                                else throw "too big number\n";
                            }
                        }
                    }else if(a.length()>max_max.length()){
                        b=0;
                        if(minus)throw "too  small number\n";
                        else throw "too big number\n";
                    }
                }
                //если число максимально минимальное
                if(tmp==max_max&&minus){
                    count=(stoll(max_max)*-1);
                    b=1;
                    if(count<min){b=0;throw "too small number\n";}
                    if(count>max){b=0;throw "too big number\n";}
                }
                else if(b&&a.length()!=0){
                    if(minus){
                        count=(-stoll(tmp));
                        if(count<min){b=0;throw "too small number\n";}
                        if(count>max){b=0;throw "too big number\n";}
                    }
                    else if(b&& a.length()!=0){
                        count=(stoll(tmp));
                        if(count<min){b=0;throw "too small number\n";}
                        if(count>max){b=0;throw "too big number\n";}
                    }
                }
            }else {
                b=0;
                throw "you have not entered anything\n";
            }
            if(b&&minus){
                b=0;
                throw "Not right Symbol\n";
            }
        }
        catch(const char *ex){
            std::cout<<ex<<"Try again\n";
        }
    }while(!b);
    return count;    
}
//проверка на double но без експоненциальной записи
double getdouble(double min,double max){        
    std::string tmp,a;bool b(0),minus(0),f(0);double count(0);
    do{    
        try{
            b=1;
            tmp="";
            a="";
            f=0;
            
            if(min>max){b=0;exit(1);}
            getline(std::cin,a);
            if(a.length()!=0){
                if(a.length()==1&&a[0]=='0'||(a.length()==3&&a[0]=='0'&&a[1]=='.'&&a[2]=='0')){
                    count=(stod(a));
                    if(count<min){b=0;throw "too small number\n";}
                    if(count>max){b=0;throw "too big number\n";}
                    b=1;
                    break;
                }
                while(a[0]=='0'&&a[1]!='.'){
                    a.erase(0,1);
                }
                if(a[0]=='-'){
                    minus=1;
                    a.erase(0,1);
                } 
                for(int i=0;i<a.length()&&b;++i){
                    if(static_cast<int>(a[i])>=48&&static_cast<int>(a[i])<=57){
                        tmp+=a[i];
                    }
                    else if(Isfloat){
                        tmp+='.';
                        for(int j=i+1;j<a.length();++j){
                            if(static_cast<int>(a[j])>=48&&static_cast<int>(a[j])<=57){
                                tmp+=a[j];
                                if(a.length()==j+1){
                                    f=1;
                                }    
                            }
                            else {
                                b=0;
                                throw "Not right symbol\n";
                            }
                        }
                    }else {
                        b=0;
                        throw "Not right symbol\n";
                    }
                    if(f){
                        break;
                    }
                }
                if(b){
                    if(a.length()>15){
                        b=0;
                        if(minus)throw "too small number\n";
                        throw "too big number\n";
                    }
                }
                if(b){
                    if(minus){
                        count=(-stod(tmp));
                        if(count<min){b=0;throw "too small number\n";}
                        if(count>max){b=0;throw "too big number\n";}
                    }
                    else{
                        count=stod(tmp);
                        if(count<min){b=0;throw "too small number\n";}
                        if(count>max){b=0;throw "too big number\n";}
                    }
                }
            }else{
                b=0;
                throw "you have not entered anything\n"; 
            }
            if(b&&minus){
                b=0;
                throw "Not right Symbol\n";
            }
        }
        catch(const char* ex){
            std::cout<<ex<<"Try Again\n";
        }
    }while(!b);
    return count;    
}
template<class T>
class _Cin{
private:
    std::vector<T> m_data;
public:
    _Cin(int c=1){ 
        std::string max_int="2147483647",max_short="32767",max_long="9223372036854775807";
        if(typeid(m_data)==typeid(std::vector<int>)){
            do{
                m_data.push_back(getnumber(INT_MIN,INT_MAX));
            }while(m_data.size()<c);
        }else if(typeid(m_data)==typeid(std::vector<short>)){
            do{
                m_data.push_back(getnumber(SHRT_MIN,SHRT_MAX));
            }while(m_data.size()<c);
        }else if(typeid(m_data)==typeid(std::vector<double>)||typeid(m_data)==typeid(std::vector<float>)){
            do{
                m_data.push_back(getdouble(DBL_MIN,DBL_MAX));
            }while(m_data.size()<c);
        }else if(typeid(m_data)==typeid(std::vector<long long int>)){
            do{
                m_data.push_back(getnumber(LLONG_MIN,LLONG_MAX));
            }while(m_data.size()<c);
        }else{
            std::cout<<"this type is not supported\n";
        }
    }
    _Cin(long long int min,long long int max,int c=1,bool plus=1){
        std::string max_int="2147483647",max_short="32767",max_long="9223372036854775807";
        if(typeid(m_data)==typeid(std::vector<int>)){
            min<INT_MIN?min=INT_MIN:min=min;
            max>INT_MAX?max=INT_MAX:max=max;
            if(plus&&min<0)min=0;
            do{
                m_data.push_back(getnumber(min,max));
            }while(m_data.size()<c);
        }else if(typeid(m_data)==typeid(std::vector<short>)){
            min<SHRT_MIN?min=SHRT_MIN:min=min;
            max>SHRT_MAX?max=SHRT_MAX:max=max;
            if(plus&&min<0)min=0;
            do{
                m_data.push_back(getnumber(min,max));
            }while(m_data.size()<c);
        }else if(typeid(m_data)==typeid(std::vector<double>)||typeid(m_data)==typeid(std::vector<float>)){
            if(plus&&min<0)min=0;
            do{
                m_data.push_back(getdouble(min,max));
            }while(m_data.size()<c);
        }else if(typeid(m_data)==typeid(std::vector<long long int>)){
            min<LLONG_MIN?min=LLONG_MIN:min=min;
            max>LLONG_MAX?max=LLONG_MAX:max=max;
            if(plus&&min<0)min=0;
            do{
                m_data.push_back(getnumber(min,max));
            }while(m_data.size()<c);
        }else{
            std::cout<<"this type is not supported\n";
        }
    }
    void print(){
        for(auto &v:m_data)std::cout<<v<<' ';
    }

    std::vector<T>& getvec(){
        return m_data; 
    }
    T getvalue(){
        return m_data[0];
    }
    operator std::vector<T>&(){return m_data;}
    operator T(return m_data[0];)
};
#endif
